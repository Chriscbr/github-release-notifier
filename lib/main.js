"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GitClient = exports.GithubClient = exports.ActionMode = void 0;
const cp = require("child_process");
const core = require("@actions/core");
const github = require("@actions/github");
const util_1 = require("./util");
var ActionMode;
(function (ActionMode) {
    /**
     * Backfills previous pull requests and issues with release reminders
     * for all previous releases as a bulk operation.
     *
     * The operation will finish when the max-backfill-operations limit is
     * reached, or when all releases have been backfilled.
     */
    ActionMode["ALL"] = "all";
    /**
     * Add release reminders to issues and pull requests for only the
     * latest available release.
     */
    ActionMode["LATEST"] = "latest";
})(ActionMode = exports.ActionMode || (exports.ActionMode = {}));
function getContext() {
    core.debug(`owner: ${github.context.repo.owner}`);
    core.debug(`repo: ${github.context.repo.repo}`);
    return github.context.repo;
}
function getOptions() {
    core.debug(`mode: ${core.getInput('mode')}`);
    core.debug(`maximum-comments: ${core.getInput('maximum-comments')}`);
    const mode = ActionMode[core.getInput('mode')];
    const maximumComments = parseInt(core.getInput('maximum-comments'), 10); // may be NaN
    const options = {
        mode: mode !== null && mode !== void 0 ? mode : ActionMode.LATEST,
        maximumComments: maximumComments || 50,
    };
    core.debug(`options: ${JSON.stringify(options)}`);
    return options;
}
class GithubClient {
    constructor(octokit, owner, repo) {
        this.octokit = octokit;
        this.owner = owner;
        this.repo = repo;
    }
    async getLatestRelease() {
        var _a;
        const response = await this.octokit.request(`GET /repos/${this.owner}/${this.repo}/releases/latest`);
        core.debug(`getLatestRelease: (${response.status}) ${(_a = response.data) === null || _a === void 0 ? void 0 : _a.name}`);
        return response.data;
    }
    async getPullRequestsFromCommit(commitSha) {
        var _a;
        const response = await this.octokit.request(`GET /repos/${this.owner}/${this.repo}/commits/${commitSha}/pulls`, {
            // specify a media type because this feature is in preview
            mediaType: {
                previews: ['groot'],
            },
        });
        core.debug(`getPullRequestsFromCommit: (${response.status}) ${(_a = response.data) === null || _a === void 0 ? void 0 : _a.map((pr) => pr.url).join('\n')}`);
        return response.data;
    }
    async getIssue(issueNumber) {
        var _a;
        const response = await this.octokit.request(`GET /repos/${this.owner}/${this.repo}/issues/${issueNumber}`);
        core.debug(`getIssue: (${response.status}) #${(_a = response.data) === null || _a === void 0 ? void 0 : _a.number}`);
        return response.data;
    }
}
exports.GithubClient = GithubClient;
class GitClient {
    constructor() {
        this.workspace = this.setupWorkspace();
    }
    setupWorkspace() {
        if (!process.env.GITHUB_WORKSPACE) {
            throw new Error('GITHUB_WORKSPACE is not set in the current repository!');
        }
        return process.env.GITHUB_WORKSPACE;
    }
    getTag(tag) {
        return cp.execSync(`git show-ref -s ${tag}`, { cwd: this.workspace }).toString().trim();
    }
    getPreviousTag(tag) {
        return cp.execSync(`git describe --tags --abbrev=0 ${tag}^`, { cwd: this.workspace }).toString().trim();
    }
    /**
     * Returns a list of commit hashes beginning AFTER fromTag, up to and
     * INCLUDING toTag.
     */
    getCommitsBetweenTags(fromTag, toTag) {
        return cp.execSync(`git rev-list ${fromTag}..${toTag}`).toString().trim().split('\n');
    }
}
exports.GitClient = GitClient;
async function getPullRequests(gitClient, githubClient, release) {
    core.debug(`getting pull requests for release: ${release.name}`);
    const tag = release.tag_name;
    core.debug(`tag: ${tag}`);
    const previousTag = gitClient.getPreviousTag(tag);
    core.debug(`previousTag: ${previousTag}`);
    const commits = gitClient.getCommitsBetweenTags(previousTag, tag);
    core.debug(`commits: ${commits}`);
    const promises = commits.map((commitSha) => githubClient.getPullRequestsFromCommit(commitSha));
    const pullRequests = (await resolveAndFilter(promises)).flat();
    // TODO: validate that the pull request was actually merged?
    // https://docs.github.com/en/rest/reference/pulls#check-if-a-pull-request-has-been-merged
    core.debug(`pullRequests: ${pullRequests.map(pr => pr.url)}`);
    return pullRequests;
}
/**
 * Returns a list of issue numbers mentioned in a pull request description.
 * @see https://docs.github.com/en/issues/tracking-your-work-with-issues/linking-a-pull-request-to-an-issue#linking-a-pull-request-to-an-issue-using-a-keyword
 */
function parseIssueNumbers(description) {
    const LINKED_ISSUE_REGEXES = [
        /close #(\d+)/g,
        /closes #(\d+)/g,
        /closed #(\d+)/g,
        /fix #(\d+)/g,
        /fixes #(\d+)/g,
        /fixed #(\d+)/g,
        /resolve #(\d+)/g,
        /resolves #(\d+)/g,
        /resolved #(\d+)/g,
    ];
    const output = [];
    for (const re of LINKED_ISSUE_REGEXES) {
        const matches = description.matchAll(re);
        for (const match of matches) {
            const issueNumber = match[1]; // grab the captured group
            output.push(parseInt(issueNumber));
        }
    }
    return output;
}
async function getLinkedIssues(githubClient, pullRequest) {
    core.debug(`getting linked issues for pull request: #${pullRequest.number}`);
    const prBody = pullRequest.body.toLowerCase();
    const issueNumbers = util_1.dedupArray(parseIssueNumbers(prBody));
    core.debug(`issue numbers found: [${issueNumbers.map((num) => '#' + num).join(',')}]`);
    const issues = await resolveAndFilter(issueNumbers.map((issueNum) => githubClient.getIssue(issueNum)));
    core.debug(`issues: ${issues.map(issue => issue.url).join('\n')}`);
    return issues;
}
async function resolveAndFilter(promises) {
    const promiseResults = await Promise.allSettled(promises);
    const output = [];
    for (const result of promiseResults) {
        if (result.status === 'fulfilled') {
            output.push(result.value);
        }
    }
    return output;
}
function filterAlreadyCommentedIssues(_githubClient, issues) {
    return issues;
}
async function run() {
    try {
        const options = getOptions();
        const { owner, repo } = getContext();
        if (options.mode !== ActionMode.LATEST) {
            throw new Error('Only "latest" mode is currently supported.');
        }
        const token = core.getInput('token', { required: true });
        if (token === 'DEBUG_TOKEN') {
            core.info('DEBUG_TOKEN has been provided, exiting early.');
            core.setOutput('total-comments', 0);
            return;
        }
        const octokit = github.getOctokit(token);
        const githubClient = new GithubClient(octokit, owner, repo);
        const gitClient = new GitClient();
        // if (process.env.DEBUG_)
        const latestRelease = await githubClient.getLatestRelease();
        const pullRequests = await getPullRequests(gitClient, githubClient, latestRelease);
        const issuesPerPullRequest = await resolveAndFilter(pullRequests.map((pr) => getLinkedIssues(githubClient, pr)));
        let issues = util_1.dedupArray(issuesPerPullRequest.flat());
        issues = filterAlreadyCommentedIssues(githubClient, issues);
        // const totalComments = await commentOn(pullRequests, issues, release);
        core.setOutput('total-comments', 0); // TODO
    }
    catch (error) {
        core.setFailed(error.message);
    }
}
// eslint-disable-next-line @typescript-eslint/no-floating-promises
run();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9tYWluLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLG9DQUFvQztBQUNwQyxzQ0FBc0M7QUFDdEMsMENBQTBDO0FBRTFDLGlDQUFvQztBQUVwQyxJQUFZLFVBZVg7QUFmRCxXQUFZLFVBQVU7SUFDcEI7Ozs7OztPQU1HO0lBQ0gseUJBQVcsQ0FBQTtJQUVYOzs7T0FHRztJQUNILCtCQUFpQixDQUFBO0FBQ25CLENBQUMsRUFmVyxVQUFVLEdBQVYsa0JBQVUsS0FBVixrQkFBVSxRQWVyQjtBQWdCRCxTQUFTLFVBQVU7SUFDakIsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLE1BQU0sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUM7SUFDbEQsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLE1BQU0sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7SUFDaEQsT0FBTyxNQUFNLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQztBQUM3QixDQUFDO0FBRUQsU0FBUyxVQUFVO0lBQ2pCLElBQUksQ0FBQyxLQUFLLENBQUMsU0FBUyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUM3QyxJQUFJLENBQUMsS0FBSyxDQUFDLHFCQUFxQixJQUFJLENBQUMsUUFBUSxDQUFDLGtCQUFrQixDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBRXJFLE1BQU0sSUFBSSxHQUFpQyxVQUFXLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0lBQzlFLE1BQU0sZUFBZSxHQUFXLFFBQVEsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLGtCQUFrQixDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxhQUFhO0lBQzlGLE1BQU0sT0FBTyxHQUFHO1FBQ2QsSUFBSSxFQUFFLElBQUks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RXJELE1BQU0sR0FBRyw0QkFBNEIsQ0FBQyxZQUFZLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFFNUQsd0VBQXdFO1FBRXhFLElBQUksQ0FBQyxTQUFTLENBQUMsZ0JBQWdCLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxPQUFPO0tBQzdDO0lBQUMsT0FBTyxLQUFLLEVBQUU7UUFDZCxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztLQUMvQjtBQUNILENBQUM7QUFFRCxtRUFBbUU7QUFDbkUsR0FBRyxFQUFFLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBjcCBmcm9tICdjaGlsZF9wcm9jZXNzJztcbmltcG9ydCAqIGFzIGNvcmUgZnJvbSAnQGFjdGlvbnMvY29yZSc7XG5pbXBvcnQgKiBhcyBnaXRodWIgZnJvbSAnQGFjdGlvbnMvZ2l0aHViJztcbmltcG9ydCB7IEdpdGh1Yklzc3VlLCBHaXRodWJQdWxsUmVxdWVzdCwgR2l0aHViUmVsZWFzZSB9IGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IHsgZGVkdXBBcnJheSB9IGZyb20gJy4vdXRpbCc7XG5cbmV4cG9ydCBlbnVtIEFjdGlvbk1vZGUge1xuICAvKipcbiAgICogQmFja2ZpbGxzIHByZXZpb3VzIHB1bGwgcmVxdWVzdHMgYW5kIGlzc3VlcyB3aXRoIHJlbGVhc2UgcmVtaW5kZXJzXG4gICAqIGZvciBhbGwgcHJldmlvdXMgcmVsZWFzZXMgYXMgYSBidWxrIG9wZXJhdGlvbi5cbiAgICpcbiAgICogVGhlIG9wZXJhdGlvbiB3aWxsIGZpbmlzaCB3aGVuIHRoZSBtYXgtYmFja2ZpbGwtb3BlcmF0aW9ucyBsaW1pdCBpc1xuICAgKiByZWFjaGVkLCBvciB3aGVuIGFsbCByZWxlYXNlcyBoYXZlIGJlZW4gYmFja2ZpbGxlZC5cbiAgICovXG4gIEFMTCA9ICdhbGwnLFxuXG4gIC8qKlxuICAgKiBBZGQgcmVsZWFzZSByZW1pbmRlcnMgdG8gaXNzdWVzIGFuZCBwdWxsIHJlcXVlc3RzIGZvciBvbmx5IHRoZVxuICAgKiBsYXRlc3QgYXZhaWxhYmxlIHJlbGVhc2UuXG4gICAqL1xuICBMQVRFU1QgPSAnbGF0ZXN0J1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEFjdGlvbk9wdGlvbnMge1xuICAvKipcbiAgICogTW9kZSBvZiBydW5uaW5nIHRoZSBhY3Rpb24uXG4gICAqIEBkZWZhdWx0IEFjdGlvbk1vZGUuTEFURVNUXG4gICAqL1xuICByZWFkb25seSBtb2RlPzogQWN0aW9uTW9kZTtcblxuICAvKipcbiAgICogTWF4aW11bSBudW1iZXIgb2YgY29tbWVudHMgdG8gYXBwbHkgd2hpbGUgcnVubmluZyB0aGUgYWN0aW9uLlxuICAgKiBAZGVmYXVsdCA1MFxuICAgKi9cbiAgcmVhZG9ubHkgbWF4aW11bUNvbW1lbnRzPzogbnVtYmVyO1xufVxuXG5mdW5jdGlvbiBnZXRDb250ZXh0KCkge1xuICBjb3JlLmRlYnVnKGBvd25lcjogJHtnaXRodWIuY29udGV4dC5yZXBvLm93bmVyfWApO1xuICBjb3JlLmRlYnVnKGByZXBvOiAke2dpdGh1Yi5jb250ZXh0LnJlcG8ucmVwb31gKTtcbiAgcmV0dXJuIGdpdGh1Yi5jb250ZXh0LnJlcG87XG59XG5cbmZ1bmN0aW9uIGdldE9wdGlvbnMoKTogQWN0aW9uT3B0aW9ucyB7XG4gIGNvcmUuZGVidWcoYG1vZGU6ICR7Y29yZS5nZXRJbnB1dCgnbW9kZScpfWApO1xuICBjb3JlLmRlYnVnKGBtYXhpbXVtLWNvbW1lbnRzOiAke2NvcmUuZ2V0SW5wdXQoJ21heGltdW0tY29tbWVudHMnKX1gKTtcblxuICBjb25zdCBtb2RlOiBBY3Rpb25Nb2RlIHwgdW5kZWZpbmVkID0gKDxhbnk+QWN0aW9uTW9kZSlbY29yZS5nZXRJbnB1dCgnbW9kZScpXTtcbiAgY29uc3QgbWF4aW11bUNvbW1lbnRzOiBudW1iZXIgPSBwYXJzZUludChjb3JlLmdldElucHV0KCdtYXhpbXVtLWNvbW1lbnRzJyksIDEwKTsgLy8gbWF5IGJlIE5hTlxuICBjb25zdCBvcHRpb25zID0ge1xuICAgIG1vZGU6IG1vZGUgPz8gQWN0aW9uTW9kZS5MQVRFU1QsXG4gICAgbWF4aW11bUNvbW1lbnRzOiBtYXhpbXVtQ29tbWVudHMgfHwgNTAsXG4gIH07XG5cbiAgY29yZS5kZWJ1Zyhgb3B0aW9uczogJHtKU09OLnN0cmluZ2lmeShvcHRpb25zKX1gKTtcblxuICByZXR1cm4gb3B0aW9ucztcbn1cblxudHlwZSBIeWRyYXRlZE9jdG9raXQgPSBSZXR1cm5UeXBlPHR5cGVvZiBnaXRodWIuZ2V0T2N0b2tpdD5cblxuZXhwb3J0IGNsYXNzIEdpdGh1YkNsaWVudCB7XG4gIHByaXZhdGUgcmVhZG9ubHkgb2N0b2tpdDogSHlkcmF0ZWRPY3Rva2l0O1xuICBwcml2YXRlIHJlYWRvbmx5IG93bmVyOiBzdHJpbmc7XG4gIHByaXZhdGUgcmVhZG9ubHkgcmVwbzogc3RyaW5nO1xuICBjb25zdHJ1Y3RvcihvY3Rva2l0OiBIeWRyYXRlZE9jdG9raXQsIG93bmVyOiBzdHJpbmcsIHJlcG86IHN0cmluZykge1xuICAgIHRoaXMub2N0b2tpdCA9IG9jdG9raXQ7XG4gICAgdGhpcy5vd25lciA9IG93bmVyO1xuICAgIHRoaXMucmVwbyA9IHJlcG87XG4gIH1cblxuICBhc3luYyBnZXRMYXRlc3RSZWxlYXNlKCk6IFByb21pc2U8R2l0aHViUmVsZWFzZT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5vY3Rva2l0LnJlcXVlc3QoYEdFVCAvcmVwb3MvJHt0aGlzLm93bmVyfS8ke3RoaXMucmVwb30vcmVsZWFzZXMvbGF0ZXN0YCk7XG4gICAgY29yZS5kZWJ1ZyhgZ2V0TGF0ZXN0UmVsZWFzZTogKCR7cmVzcG9uc2Uuc3RhdHVzfSkgJHtyZXNwb25zZS5kYXRhPy5uYW1lfWApO1xuXG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH1cblxuICBhc3luYyBnZXRQdWxsUmVxdWVzdHNGcm9tQ29tbWl0KGNvbW1pdFNoYTogc3RyaW5nKTogUHJvbWlzZTxHaXRodWJQdWxsUmVxdWVzdFtdPiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLm9jdG9raXQucmVxdWVzdChgR0VUIC9yZXBvcy8ke3RoaXMub3duZXJ9LyR7dGhpcy5yZXBvfS9jb21taXRzLyR7Y29tbWl0U2hhfS9wdWxsc2AsIHtcbiAgICAgIC8vIHNwZWNpZnkgYSBtZWRpYSB0eXBlIGJlY2F1c2UgdGhpcyBmZWF0dXJlIGlzIGluIHByZXZpZXdcbiAgICAgIG1lZGlhVHlwZToge1xuICAgICAgICBwcmV2aWV3czogWydncm9vdCddLFxuICAgICAgfSxcbiAgICB9KTtcbiAgICBjb3JlLmRlYnVnKGBnZXRQdWxsUmVxdWVzdHNGcm9tQ29tbWl0OiAoJHtyZXNwb25zZS5zdGF0dXN9KSAke3Jlc3BvbnNlLmRhdGE/Lm1hcCgocHI6IEdpdGh1YlB1bGxSZXF1ZXN0KSA9PiBwci51cmwpLmpvaW4oJ1xcbicpfWApO1xuXG4gICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gIH1cblxuICBhc3luYyBnZXRJc3N1ZShpc3N1ZU51bWJlcjogbnVtYmVyKTogUHJvbWlzZTxHaXRodWJJc3N1ZT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5vY3Rva2l0LnJlcXVlc3QoYEdFVCAvcmVwb3MvJHt0aGlzLm93bmVyfS8ke3RoaXMucmVwb30vaXNzdWVzLyR7aXNzdWVOdW1iZXJ9YCk7XG4gICAgY29yZS5kZWJ1ZyhgZ2V0SXNzdWU6ICgke3Jlc3BvbnNlLnN0YXR1c30pICMke3Jlc3BvbnNlLmRhdGE/Lm51bWJlcn1gKTtcblxuICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBHaXRDbGllbnQge1xuICBwcml2YXRlIHJlYWRvbmx5IHdvcmtzcGFjZTogc3RyaW5nO1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLndvcmtzcGFjZSA9IHRoaXMuc2V0dXBXb3Jrc3BhY2UoKTtcbiAgfVxuXG4gIHNldHVwV29ya3NwYWNlKCkge1xuICAgIGlmICghcHJvY2Vzcy5lbnYuR0lUSFVCX1dPUktTUEFDRSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdHSVRIVUJfV09SS1NQQUNFIGlzIG5vdCBzZXQgaW4gdGhlIGN1cnJlbnQgcmVwb3NpdG9yeSEnKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2Nlc3MuZW52LkdJVEhVQl9XT1JLU1BBQ0U7XG4gIH1cblxuICBnZXRUYWcodGFnOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBjcC5leGVjU3luYyhgZ2l0IHNob3ctcmVmIC1zICR7dGFnfWAsIHsgY3dkOiB0aGlzLndvcmtzcGFjZSB9KS50b1N0cmluZygpLnRyaW0oKTtcbiAgfVxuXG4gIGdldFByZXZpb3VzVGFnKHRhZzogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gY3AuZXhlY1N5bmMoYGdpdCBkZXNjcmliZSAtLXRhZ3MgLS1hYmJyZXY9MCAke3RhZ31eYCwgeyBjd2Q6IHRoaXMud29ya3NwYWNlIH0pLnRvU3RyaW5nKCkudHJpbSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsaXN0IG9mIGNvbW1pdCBoYXNoZXMgYmVnaW5uaW5nIEFGVEVSIGZyb21UYWcsIHVwIHRvIGFuZFxuICAgKiBJTkNMVURJTkcgdG9UYWcuXG4gICAqL1xuICBnZXRDb21taXRzQmV0d2VlblRhZ3MoZnJvbVRhZzogc3RyaW5nLCB0b1RhZzogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgIHJldHVybiBjcC5leGVjU3luYyhgZ2l0IHJldi1saXN0ICR7ZnJvbVRhZ30uLiR7dG9UYWd9YCkudG9TdHJpbmcoKS50cmltKCkuc3BsaXQoJ1xcbicpO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldFB1bGxSZXF1ZXN0cyhnaXRDbGllbnQ6IEdpdENsaWVudCwgZ2l0aHViQ2xpZW50OiBHaXRodWJDbGllbnQsIHJlbGVhc2U6IEdpdGh1YlJlbGVhc2UpOiBQcm9taXNlPEdpdGh1YlB1bGxSZXF1ZXN0W10+IHtcbiAgY29yZS5kZWJ1ZyhgZ2V0dGluZyBwdWxsIHJlcXVlc3RzIGZvciByZWxlYXNlOiAke3JlbGVhc2UubmFtZX1gKTtcblxuICBjb25zdCB0YWcgPSByZWxlYXNlLnRhZ19uYW1lO1xuICBjb3JlLmRlYnVnKGB0YWc6ICR7dGFnfWApO1xuXG4gIGNvbnN0IHByZXZpb3VzVGFnID0gZ2l0Q2xpZW50LmdldFByZXZpb3VzVGFnKHRhZyk7XG4gIGNvcmUuZGVidWcoYHByZXZpb3VzVGFnOiAke3ByZXZpb3VzVGFnfWApO1xuXG4gIGNvbnN0IGNvbW1pdHMgPSBnaXRDbGllbnQuZ2V0Q29tbWl0c0JldHdlZW5UYWdzKHByZXZpb3VzVGFnLCB0YWcpO1xuICBjb3JlLmRlYnVnKGBjb21taXRzOiAke2NvbW1pdHN9YCk7XG5cbiAgY29uc3QgcHJvbWlzZXMgPSBjb21taXRzLm1hcCgoY29tbWl0U2hhKSA9PiBnaXRodWJDbGllbnQuZ2V0UHVsbFJlcXVlc3RzRnJvbUNvbW1pdChjb21taXRTaGEpKTtcbiAgY29uc3QgcHVsbFJlcXVlc3RzOiBHaXRodWJQdWxsUmVxdWVzdFtdID0gKGF3YWl0IHJlc29sdmVBbmRGaWx0ZXIocHJvbWlzZXMpKS5mbGF0KCk7XG5cbiAgLy8gVE9ETzogdmFsaWRhdGUgdGhhdCB0aGUgcHVsbCByZXF1ZXN0IHdhcyBhY3R1YWxseSBtZXJnZWQ/XG4gIC8vIGh0dHBzOi8vZG9jcy5naXRodWIuY29tL2VuL3Jlc3QvcmVmZXJlbmNlL3B1bGxzI2NoZWNrLWlmLWEtcHVsbC1yZXF1ZXN0LWhhcy1iZWVuLW1lcmdlZFxuXG4gIGNvcmUuZGVidWcoYHB1bGxSZXF1ZXN0czogJHtwdWxsUmVxdWVzdHMubWFwKHByID0+IHByLnVybCl9YCk7XG5cbiAgcmV0dXJuIHB1bGxSZXF1ZXN0cztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgbGlzdCBvZiBpc3N1ZSBudW1iZXJzIG1lbnRpb25lZCBpbiBhIHB1bGwgcmVxdWVzdCBkZXNjcmlwdGlvbi5cbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLmdpdGh1Yi5jb20vZW4vaXNzdWVzL3RyYWNraW5nLXlvdXItd29yay13aXRoLWlzc3Vlcy9saW5raW5nLWEtcHVsbC1yZXF1ZXN0LXRvLWFuLWlzc3VlI2xpbmtpbmctYS1wdWxsLXJlcXVlc3QtdG8tYW4taXNzdWUtdXNpbmctYS1rZXl3b3JkXG4gKi9cbmZ1bmN0aW9uIHBhcnNlSXNzdWVOdW1iZXJzKGRlc2NyaXB0aW9uOiBzdHJpbmcpOiBudW1iZXJbXSB7XG4gIGNvbnN0IExJTktFRF9JU1NVRV9SRUdFWEVTID0gW1xuICAgIC9jbG9zZSAjKFxcZCspL2csXG4gICAgL2Nsb3NlcyAjKFxcZCspL2csXG4gICAgL2Nsb3NlZCAjKFxcZCspL2csXG4gICAgL2ZpeCAjKFxcZCspL2csXG4gICAgL2ZpeGVzICMoXFxkKykvZyxcbiAgICAvZml4ZWQgIyhcXGQrKS9nLFxuICAgIC9yZXNvbHZlICMoXFxkKykvZyxcbiAgICAvcmVzb2x2ZXMgIyhcXGQrKS9nLFxuICAgIC9yZXNvbHZlZCAjKFxcZCspL2csXG4gIF07XG5cbiAgY29uc3Qgb3V0cHV0ID0gW107XG4gIGZvciAoY29uc3QgcmUgb2YgTElOS0VEX0lTU1VFX1JFR0VYRVMpIHtcbiAgICBjb25zdCBtYXRjaGVzID0gZGVzY3JpcHRpb24ubWF0Y2hBbGwocmUpO1xuICAgIGZvciAoY29uc3QgbWF0Y2ggb2YgbWF0Y2hlcykge1xuICAgICAgY29uc3QgaXNzdWVOdW1iZXIgPSBtYXRjaFsxXTsgLy8gZ3JhYiB0aGUgY2FwdHVyZWQgZ3JvdXBcbiAgICAgIG91dHB1dC5wdXNoKHBhcnNlSW50KGlzc3VlTnVtYmVyKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldExpbmtlZElzc3VlcyhnaXRodWJDbGllbnQ6IEdpdGh1YkNsaWVudCwgcHVsbFJlcXVlc3Q6IEdpdGh1YlB1bGxSZXF1ZXN0KTogUHJvbWlzZTxHaXRodWJJc3N1ZVtdPiB7XG4gIGNvcmUuZGVidWcoYGdldHRpbmcgbGlua2VkIGlzc3VlcyBmb3IgcHVsbCByZXF1ZXN0OiAjJHtwdWxsUmVxdWVzdC5udW1iZXJ9YCk7XG5cbiAgY29uc3QgcHJCb2R5ID0gcHVsbFJlcXVlc3QuYm9keS50b0xvd2VyQ2FzZSgpO1xuXG4gIGNvbnN0IGlzc3VlTnVtYmVyczogbnVtYmVyW10gPSBkZWR1cEFycmF5KHBhcnNlSXNzdWVOdW1iZXJzKHByQm9keSkpO1xuICBjb3JlLmRlYnVnKGBpc3N1ZSBudW1iZXJzIGZvdW5kOiBbJHtpc3N1ZU51bWJlcnMubWFwKChudW0pID0+ICcjJyArIG51bSkuam9pbignLCcpfV1gKTtcblxuICBjb25zdCBpc3N1ZXM6IEdpdGh1Yklzc3VlW10gPSBhd2FpdCByZXNvbHZlQW5kRmlsdGVyKGlzc3VlTnVtYmVycy5tYXAoKGlzc3VlTnVtKSA9PiBnaXRodWJDbGllbnQuZ2V0SXNzdWUoaXNzdWVOdW0pKSk7XG4gIGNvcmUuZGVidWcoYGlzc3VlczogJHtpc3N1ZXMubWFwKGlzc3VlID0+IGlzc3VlLnVybCkuam9pbignXFxuJyl9YCk7XG5cbiAgcmV0dXJuIGlzc3Vlcztcbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZUFuZEZpbHRlcjxUPihwcm9taXNlczogUHJvbWlzZTxUPltdKTogUHJvbWlzZTxUW10+IHtcbiAgY29uc3QgcHJvbWlzZVJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQocHJvbWlzZXMpO1xuICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgZm9yIChjb25zdCByZXN1bHQgb2YgcHJvbWlzZVJlc3VsdHMpIHtcbiAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCcpIHtcbiAgICAgIG91dHB1dC5wdXNoKHJlc3VsdC52YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbmZ1bmN0aW9uIGZpbHRlckFscmVhZHlDb21tZW50ZWRJc3N1ZXMoX2dpdGh1YkNsaWVudDogR2l0aHViQ2xpZW50LCBpc3N1ZXM6IEdpdGh1Yklzc3VlW10pOiBHaXRodWJJc3N1ZVtdIHtcbiAgcmV0dXJuIGlzc3Vlcztcbn1cblxuYXN5bmMgZnVuY3Rpb24gcnVuKCk6IFByb21pc2U8dm9pZD4ge1xuICB0cnkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBnZXRPcHRpb25zKCk7XG4gICAgY29uc3QgeyBvd25lciwgcmVwbyB9ID0gZ2V0Q29udGV4dCgpO1xuXG4gICAgaWYgKG9wdGlvbnMubW9kZSAhPT0gQWN0aW9uTW9kZS5MQVRFU1QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignT25seSBcImxhdGVzdFwiIG1vZGUgaXMgY3VycmVudGx5IHN1cHBvcnRlZC4nKTtcbiAgICB9XG5cbiAgICBjb25zdCB0b2tlbiA9IGNvcmUuZ2V0SW5wdXQoJ3Rva2VuJywgeyByZXF1aXJlZDogdHJ1ZSB9KTtcblxuICAgIGlmICh0b2tlbiA9PT0gJ0RFQlVHX1RPS0VOJykge1xuICAgICAgY29yZS5pbmZvKCdERUJVR19UT0tFTiBoYXMgYmVlbiBwcm92aWRlZCwgZXhpdGluZyBlYXJseS4nKTtcbiAgICAgIGNvcmUuc2V0T3V0cHV0KCd0b3RhbC1jb21tZW50cycsIDApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG9jdG9raXQgPSBnaXRodWIuZ2V0T2N0b2tpdCh0b2tlbik7XG4gICAgY29uc3QgZ2l0aHViQ2xpZW50ID0gbmV3IEdpdGh1YkNsaWVudChvY3Rva2l0LCBvd25lciwgcmVwbyk7XG4gICAgY29uc3QgZ2l0Q2xpZW50ID0gbmV3IEdpdENsaWVudCgpO1xuXG4gICAgLy8gaWYgKHByb2Nlc3MuZW52LkRFQlVHXylcbiAgICBjb25zdCBsYXRlc3RSZWxlYXNlID0gYXdhaXQgZ2l0aHViQ2xpZW50LmdldExhdGVzdFJlbGVhc2UoKTtcbiAgICBjb25zdCBwdWxsUmVxdWVzdHMgPSBhd2FpdCBnZXRQdWxsUmVxdWVzdHMoZ2l0Q2xpZW50LCBnaXRodWJDbGllbnQsIGxhdGVzdFJlbGVhc2UpO1xuXG4gICAgY29uc3QgaXNzdWVzUGVyUHVsbFJlcXVlc3Q6IEdpdGh1Yklzc3VlW11bXSA9IGF3YWl0IHJlc29sdmVBbmRGaWx0ZXIocHVsbFJlcXVlc3RzLm1hcCgocHIpID0+IGdldExpbmtlZElzc3VlcyhnaXRodWJDbGllbnQsIHByKSkpO1xuICAgIGxldCBpc3N1ZXMgPSBkZWR1cEFycmF5KGlzc3Vlc1BlclB1bGxSZXF1ZXN0LmZsYXQoKSk7XG5cbiAgICBpc3N1ZXMgPSBmaWx0ZXJBbHJlYWR5Q29tbWVudGVkSXNzdWVzKGdpdGh1YkNsaWVudCwgaXNzdWVzKTtcblxuICAgIC8vIGNvbnN0IHRvdGFsQ29tbWVudHMgPSBhd2FpdCBjb21tZW50T24ocHVsbFJlcXVlc3RzLCBpc3N1ZXMsIHJlbGVhc2UpO1xuXG4gICAgY29yZS5zZXRPdXRwdXQoJ3RvdGFsLWNvbW1lbnRzJywgMCk7IC8vIFRPRE9cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb3JlLnNldEZhaWxlZChlcnJvci5tZXNzYWdlKTtcbiAgfVxufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWZsb2F0aW5nLXByb21pc2VzXG5ydW4oKTsiXX0=
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GitClient = exports.GithubClient = exports.ActionMode = void 0;
const cp = require("child_process");
const core = require("@actions/core");
const github = require("@actions/github");
var ActionMode;
(function (ActionMode) {
    /**
     * Backfills previous pull requests and issues with release reminders
     * for all previous releases as a bulk operation.
     *
     * The operation will finish when the max-backfill-operations limit is
     * reached, or when all releases have been backfilled.
     */
    ActionMode["ALL"] = "all";
    /**
     * Add release reminders to issues and pull requests for only the
     * latest available release.
     */
    ActionMode["LATEST"] = "continuous";
})(ActionMode = exports.ActionMode || (exports.ActionMode = {}));
function getContext() {
    core.debug(`owner: ${github.context.repo.owner}`);
    core.debug(`repo: ${github.context.repo.repo}`);
    return github.context.repo;
}
function getOptions() {
    core.debug(`mode: ${core.getInput('mode')}`);
    core.debug(`maximum-comments: ${core.getInput('maximum-comments')}`);
    const mode = ActionMode[core.getInput('mode')];
    const maximumComments = parseInt(core.getInput('maximum-comments'), 10); // may be NaN
    const options = {
        mode: mode !== null && mode !== void 0 ? mode : ActionMode.LATEST,
        maximumComments: maximumComments || 50,
    };
    core.debug(`options: ${JSON.stringify(options)}`);
    return options;
}
class GithubClient {
    constructor(octokit, owner, repo) {
        this.octokit = octokit;
        this.owner = owner;
        this.repo = repo;
    }
    async getLatestRelease() {
        return this.octokit.request(`GET /repos/${this.owner}/${this.repo}/releases/latest`);
        // return this.octokit.rest.repos.getLatestRelease({
        //   owner: this.owner,
        //   repo: this.repo,
        // });
    }
    async getPullRequests(commitSha) {
        return this.octokit.request(`GET /repos/${this.owner}/${this.repo}/commits/${commitSha}/pulls`);
    }
}
exports.GithubClient = GithubClient;
class GitClient {
    constructor() {
        this.workspace = this.setupWorkspace();
    }
    setupWorkspace() {
        if (!process.env.GITHUB_WORKSPACE) {
            throw new Error('GITHUB_WORKSPACE is not set in the current repository!');
        }
        return process.env.GITHUB_WORKSPACE;
    }
    getTag(tag) {
        return cp.execSync(`git show-ref -s ${tag}`, { cwd: this.workspace }).toString().trim();
    }
    getPreviousTag(tag) {
        return cp.execSync(`git describe --tags --abbrev=0 ${tag}^`, { cwd: this.workspace }).toString().trim();
    }
    /**
     * Returns a list of commit hashes beginning AFTER fromTag, up to and
     * INCLUDING toTag.
     */
    getCommitsBetweenTags(fromTag, toTag) {
        return cp.execSync(`git rev-list ${fromTag}..${toTag}`).toString().trim().split('\n');
    }
}
exports.GitClient = GitClient;
async function getPullRequests(gitClient, githubClient, release) {
    const tag = release.tag_name;
    const previousTag = gitClient.getPreviousTag(tag);
    const commits = gitClient.getCommitsBetweenTags(previousTag, tag);
    console.error(commits);
    const promises = commits.map((commitSha) => githubClient.getPullRequests(commitSha));
    const pullRequestsResults = (await Promise.allSettled(promises)).flat();
    const pullRequests = [];
    for (const result of pullRequestsResults) {
        if (result.status === 'fulfilled') {
            pullRequests.push(result.value.data);
        }
    }
    console.error(pullRequests);
    return pullRequests;
}
function getLinkedIssues(_pullRequests) {
    return [];
}
async function run() {
    try {
        const options = getOptions();
        const { owner, repo } = getContext();
        if (options.mode !== ActionMode.LATEST) {
            throw new Error('Only "latest" mode is currently supported.');
        }
        const token = core.getInput('token', { required: true });
        if (token === 'DEBUG_TOKEN') {
            core.info('DEBUG_TOKEN has been provided, exiting early.');
            core.setOutput('total-comments', 0);
            return;
        }
        const octokit = github.getOctokit(token);
        const githubClient = new GithubClient(octokit, owner, repo);
        const gitClient = new GitClient();
        const { data: latestRelease } = await githubClient.getLatestRelease();
        core.debug(`latest release: ${JSON.stringify(latestRelease)}`);
        const pullRequests = await getPullRequests(gitClient, githubClient, latestRelease);
        core.debug('pull requests:' + pullRequests.map((pr) => pr.title).join('\n'));
        getLinkedIssues(pullRequests); // TODO
        // const totalComments = await commentOn(pullRequests, issues, release);
        core.info('Success!');
        core.setOutput('total-comments', 0); // TODO
    }
    catch (error) {
        core.setFailed(error.message);
    }
}
// eslint-disable-next-line @typescript-eslint/no-floating-promises
run();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9tYWluLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLG9DQUFvQztBQUNwQyxzQ0FBc0M7QUFDdEMsMENBQTBDO0FBSTFDLElBQVksVUFlWDtBQWZELFdBQVksVUFBVTtJQUNwQjs7Ozs7O09BTUc7SUFDSCx5QkFBVyxDQUFBO0lBRVg7OztPQUdHO0lBQ0gsbUNBQXFCLENBQUE7QUFDdkIsQ0FBQyxFQWZXLFVBQVUsR0FBVixrQkFBVSxLQUFWLGtCQUFVLFFBZXJCO0FBZ0JELFNBQVMsVUFBVTtJQUNqQixJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsTUFBTSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztJQUNsRCxJQUFJLENBQUMsS0FBSyxDQUFDLFNBQVMsTUFBTSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQztJQUNoRCxPQUFPLE1BQU0sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDO0FBQzdCLENBQUM7QUFFRCxTQUFTLFVBQVU7SUFDakIsSUFBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQzdDLElBQUksQ0FBQyxLQUFLLENBQUMscUJBQXFCLElBQUksQ0FBQyxRQUFRLENBQUMsa0JBQWtCLENBQUMsRUFBRSxDQUFDLENBQUM7SUFFckUsTUFBTSxJQUFJLEdBQWlDLFVBQVcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7SUFDOUUsTUFBTSxlQUFlLEdBQVcsUUFBUSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsa0JBQWtCLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLGFBQWE7SUFDOUYsTUFBTSxPQUFPLEdBQUc7UUFDZCxJQUFJLEVBQUUsSUFBSSxhQUFKLElBQUksY0FB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QyxLQUFLLENBQUMsQ0FBQztRQUN6QyxNQUFNLFlBQVksR0FBRyxJQUFJLFlBQVksQ0FBQyxPQUFPLEVBQUUsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQzVELE1BQU0sU0FBUyxHQUFHLElBQUksU0FBUyxFQUFFLENBQUM7UUFFbEMsTUFBTSxFQUFFLElBQUksRUFBRSxhQUFhLEVBQUUsR0FBRyxNQUFNLFlBQVksQ0FBQyxnQkFBZ0IsRUFBRSxDQUFDO1FBQ3RFLElBQUksQ0FBQyxLQUFLLENBQUMsbUJBQW1CLElBQUksQ0FBQyxTQUFTLENBQUMsYUFBYSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQy9ELE1BQU0sWUFBWSxHQUFHLE1BQU0sZUFBZSxDQUFDLFNBQVMsRUFBRSxZQUFZLEVBQUUsYUFBYSxDQUFDLENBQUM7UUFDbkYsSUFBSSxDQUFDLEtBQUssQ0FBQyxnQkFBZ0IsR0FBRyxZQUFZLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7UUFFN0UsZUFBZSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsT0FBTztRQUV0Qyx3RUFBd0U7UUFFeEUsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUN0QixJQUFJLENBQUMsU0FBUyxDQUFDLGdCQUFnQixFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTztLQUM3QztJQUFDLE9BQU8sS0FBSyxFQUFFO1FBQ2QsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7S0FDL0I7QUFDSCxDQUFDO0FBRUQsbUVBQW1FO0FBQ25FLEdBQUcsRUFBRSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgY3AgZnJvbSAnY2hpbGRfcHJvY2Vzcyc7XG5pbXBvcnQgKiBhcyBjb3JlIGZyb20gJ0BhY3Rpb25zL2NvcmUnO1xuaW1wb3J0ICogYXMgZ2l0aHViIGZyb20gJ0BhY3Rpb25zL2dpdGh1Yic7XG5pbXBvcnQgeyBPY3Rva2l0UmVzcG9uc2UgfSBmcm9tICdAb2N0b2tpdC90eXBlcyc7XG5pbXBvcnQgeyBHaXRodWJQdWxsUmVxdWVzdCwgR2l0aHViUmVsZWFzZSB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgZW51bSBBY3Rpb25Nb2RlIHtcbiAgLyoqXG4gICAqIEJhY2tmaWxscyBwcmV2aW91cyBwdWxsIHJlcXVlc3RzIGFuZCBpc3N1ZXMgd2l0aCByZWxlYXNlIHJlbWluZGVyc1xuICAgKiBmb3IgYWxsIHByZXZpb3VzIHJlbGVhc2VzIGFzIGEgYnVsayBvcGVyYXRpb24uXG4gICAqXG4gICAqIFRoZSBvcGVyYXRpb24gd2lsbCBmaW5pc2ggd2hlbiB0aGUgbWF4LWJhY2tmaWxsLW9wZXJhdGlvbnMgbGltaXQgaXNcbiAgICogcmVhY2hlZCwgb3Igd2hlbiBhbGwgcmVsZWFzZXMgaGF2ZSBiZWVuIGJhY2tmaWxsZWQuXG4gICAqL1xuICBBTEwgPSAnYWxsJyxcblxuICAvKipcbiAgICogQWRkIHJlbGVhc2UgcmVtaW5kZXJzIHRvIGlzc3VlcyBhbmQgcHVsbCByZXF1ZXN0cyBmb3Igb25seSB0aGVcbiAgICogbGF0ZXN0IGF2YWlsYWJsZSByZWxlYXNlLlxuICAgKi9cbiAgTEFURVNUID0gJ2NvbnRpbnVvdXMnXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQWN0aW9uT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBNb2RlIG9mIHJ1bm5pbmcgdGhlIGFjdGlvbi5cbiAgICogQGRlZmF1bHQgQWN0aW9uTW9kZS5MQVRFU1RcbiAgICovXG4gIHJlYWRvbmx5IG1vZGU/OiBBY3Rpb25Nb2RlO1xuXG4gIC8qKlxuICAgKiBNYXhpbXVtIG51bWJlciBvZiBjb21tZW50cyB0byBhcHBseSB3aGlsZSBydW5uaW5nIHRoZSBhY3Rpb24uXG4gICAqIEBkZWZhdWx0IDUwXG4gICAqL1xuICByZWFkb25seSBtYXhpbXVtQ29tbWVudHM/OiBudW1iZXI7XG59XG5cbmZ1bmN0aW9uIGdldENvbnRleHQoKSB7XG4gIGNvcmUuZGVidWcoYG93bmVyOiAke2dpdGh1Yi5jb250ZXh0LnJlcG8ub3duZXJ9YCk7XG4gIGNvcmUuZGVidWcoYHJlcG86ICR7Z2l0aHViLmNvbnRleHQucmVwby5yZXBvfWApO1xuICByZXR1cm4gZ2l0aHViLmNvbnRleHQucmVwbztcbn1cblxuZnVuY3Rpb24gZ2V0T3B0aW9ucygpOiBBY3Rpb25PcHRpb25zIHtcbiAgY29yZS5kZWJ1ZyhgbW9kZTogJHtjb3JlLmdldElucHV0KCdtb2RlJyl9YCk7XG4gIGNvcmUuZGVidWcoYG1heGltdW0tY29tbWVudHM6ICR7Y29yZS5nZXRJbnB1dCgnbWF4aW11bS1jb21tZW50cycpfWApO1xuXG4gIGNvbnN0IG1vZGU6IEFjdGlvbk1vZGUgfCB1bmRlZmluZWQgPSAoPGFueT5BY3Rpb25Nb2RlKVtjb3JlLmdldElucHV0KCdtb2RlJyldO1xuICBjb25zdCBtYXhpbXVtQ29tbWVudHM6IG51bWJlciA9IHBhcnNlSW50KGNvcmUuZ2V0SW5wdXQoJ21heGltdW0tY29tbWVudHMnKSwgMTApOyAvLyBtYXkgYmUgTmFOXG4gIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgbW9kZTogbW9kZSA/PyBBY3Rpb25Nb2RlLkxBVEVTVCxcbiAgICBtYXhpbXVtQ29tbWVudHM6IG1heGltdW1Db21tZW50cyB8fCA1MCxcbiAgfTtcblxuICBjb3JlLmRlYnVnKGBvcHRpb25zOiAke0pTT04uc3RyaW5naWZ5KG9wdGlvbnMpfWApO1xuXG4gIHJldHVybiBvcHRpb25zO1xufVxuXG50eXBlIEh5ZHJhdGVkT2N0b2tpdCA9IFJldHVyblR5cGU8dHlwZW9mIGdpdGh1Yi5nZXRPY3Rva2l0PlxuXG5leHBvcnQgY2xhc3MgR2l0aHViQ2xpZW50IHtcbiAgcHJpdmF0ZSByZWFkb25seSBvY3Rva2l0OiBIeWRyYXRlZE9jdG9raXQ7XG4gIHByaXZhdGUgcmVhZG9ubHkgb3duZXI6IHN0cmluZztcbiAgcHJpdmF0ZSByZWFkb25seSByZXBvOiBzdHJpbmc7XG4gIGNvbnN0cnVjdG9yKG9jdG9raXQ6IEh5ZHJhdGVkT2N0b2tpdCwgb3duZXI6IHN0cmluZywgcmVwbzogc3RyaW5nKSB7XG4gICAgdGhpcy5vY3Rva2l0ID0gb2N0b2tpdDtcbiAgICB0aGlzLm93bmVyID0gb3duZXI7XG4gICAgdGhpcy5yZXBvID0gcmVwbztcbiAgfVxuXG4gIGFzeW5jIGdldExhdGVzdFJlbGVhc2UoKTogUHJvbWlzZTxPY3Rva2l0UmVzcG9uc2U8R2l0aHViUmVsZWFzZSwgbnVtYmVyPj4ge1xuICAgIHJldHVybiB0aGlzLm9jdG9raXQucmVxdWVzdChgR0VUIC9yZXBvcy8ke3RoaXMub3duZXJ9LyR7dGhpcy5yZXBvfS9yZWxlYXNlcy9sYXRlc3RgKTtcbiAgICAvLyByZXR1cm4gdGhpcy5vY3Rva2l0LnJlc3QucmVwb3MuZ2V0TGF0ZXN0UmVsZWFzZSh7XG4gICAgLy8gICBvd25lcjogdGhpcy5vd25lcixcbiAgICAvLyAgIHJlcG86IHRoaXMucmVwbyxcbiAgICAvLyB9KTtcbiAgfVxuXG4gIGFzeW5jIGdldFB1bGxSZXF1ZXN0cyhjb21taXRTaGE6IHN0cmluZyk6IFByb21pc2U8T2N0b2tpdFJlc3BvbnNlPEdpdGh1YlB1bGxSZXF1ZXN0LCBudW1iZXI+PiB7XG4gICAgcmV0dXJuIHRoaXMub2N0b2tpdC5yZXF1ZXN0KGBHRVQgL3JlcG9zLyR7dGhpcy5vd25lcn0vJHt0aGlzLnJlcG99L2NvbW1pdHMvJHtjb21taXRTaGF9L3B1bGxzYCk7XG4gIH1cblxuICAvLyBnZXRUYWcodGFnOiBzdHJpbmcpIHtcbiAgLy8gICAvLyByZXR1cm4gdGhpcy5vY3Rva2l0LnJlcXVlc3QoYEdFVCAvcmVwb3MvJHt0aGlzLm93bmVyfS8ke3RoaXMucmVwb30vZ2l0L3JlZnMvdGFncy8ke3RhZ31gKTtcbiAgLy8gICByZXR1cm4gdGhpcy5vY3Rva2l0LnJlc3QuZ2l0LmdldFJlZih7XG4gIC8vICAgICBvd25lcjogdGhpcy5vd25lcixcbiAgLy8gICAgIHJlcG86IHRoaXMucmVwbyxcbiAgLy8gICAgIHJlZjogYHJlZnMvdGFncy8ke3RhZ31gLFxuICAvLyAgIH0pO1xuICAvLyB9XG59XG5cbmV4cG9ydCBjbGFzcyBHaXRDbGllbnQge1xuICBwcml2YXRlIHJlYWRvbmx5IHdvcmtzcGFjZTogc3RyaW5nO1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLndvcmtzcGFjZSA9IHRoaXMuc2V0dXBXb3Jrc3BhY2UoKTtcbiAgfVxuXG4gIHNldHVwV29ya3NwYWNlKCkge1xuICAgIGlmICghcHJvY2Vzcy5lbnYuR0lUSFVCX1dPUktTUEFDRSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdHSVRIVUJfV09SS1NQQUNFIGlzIG5vdCBzZXQgaW4gdGhlIGN1cnJlbnQgcmVwb3NpdG9yeSEnKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2Nlc3MuZW52LkdJVEhVQl9XT1JLU1BBQ0U7XG4gIH1cblxuICBnZXRUYWcodGFnOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIHJldHVybiBjcC5leGVjU3luYyhgZ2l0IHNob3ctcmVmIC1zICR7dGFnfWAsIHsgY3dkOiB0aGlzLndvcmtzcGFjZSB9KS50b1N0cmluZygpLnRyaW0oKTtcbiAgfVxuXG4gIGdldFByZXZpb3VzVGFnKHRhZzogc3RyaW5nKTogc3RyaW5nIHtcbiAgICByZXR1cm4gY3AuZXhlY1N5bmMoYGdpdCBkZXNjcmliZSAtLXRhZ3MgLS1hYmJyZXY9MCAke3RhZ31eYCwgeyBjd2Q6IHRoaXMud29ya3NwYWNlIH0pLnRvU3RyaW5nKCkudHJpbSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsaXN0IG9mIGNvbW1pdCBoYXNoZXMgYmVnaW5uaW5nIEFGVEVSIGZyb21UYWcsIHVwIHRvIGFuZFxuICAgKiBJTkNMVURJTkcgdG9UYWcuXG4gICAqL1xuICBnZXRDb21taXRzQmV0d2VlblRhZ3MoZnJvbVRhZzogc3RyaW5nLCB0b1RhZzogc3RyaW5nKTogc3RyaW5nW10ge1xuICAgIHJldHVybiBjcC5leGVjU3luYyhgZ2l0IHJldi1saXN0ICR7ZnJvbVRhZ30uLiR7dG9UYWd9YCkudG9TdHJpbmcoKS50cmltKCkuc3BsaXQoJ1xcbicpO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldFB1bGxSZXF1ZXN0cyhnaXRDbGllbnQ6IEdpdENsaWVudCwgZ2l0aHViQ2xpZW50OiBHaXRodWJDbGllbnQsIHJlbGVhc2U6IEdpdGh1YlJlbGVhc2UpOiBQcm9taXNlPEdpdGh1YlB1bGxSZXF1ZXN0W10+IHtcbiAgY29uc3QgdGFnID0gcmVsZWFzZS50YWdfbmFtZTtcbiAgY29uc3QgcHJldmlvdXNUYWcgPSBnaXRDbGllbnQuZ2V0UHJldmlvdXNUYWcodGFnKTtcbiAgY29uc3QgY29tbWl0cyA9IGdpdENsaWVudC5nZXRDb21taXRzQmV0d2VlblRhZ3MocHJldmlvdXNUYWcsIHRhZyk7XG4gIGNvbnNvbGUuZXJyb3IoY29tbWl0cyk7XG5cbiAgY29uc3QgcHJvbWlzZXMgPSBjb21taXRzLm1hcCgoY29tbWl0U2hhKSA9PiBnaXRodWJDbGllbnQuZ2V0UHVsbFJlcXVlc3RzKGNvbW1pdFNoYSkpO1xuICBjb25zdCBwdWxsUmVxdWVzdHNSZXN1bHRzID0gKGF3YWl0IFByb21pc2UuYWxsU2V0dGxlZChwcm9taXNlcykpLmZsYXQoKTtcbiAgY29uc3QgcHVsbFJlcXVlc3RzID0gW107XG4gIGZvciAoY29uc3QgcmVzdWx0IG9mIHB1bGxSZXF1ZXN0c1Jlc3VsdHMpIHtcbiAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCcpIHtcbiAgICAgIHB1bGxSZXF1ZXN0cy5wdXNoKHJlc3VsdC52YWx1ZS5kYXRhKTtcbiAgICB9XG4gIH1cbiAgY29uc29sZS5lcnJvcihwdWxsUmVxdWVzdHMpO1xuICByZXR1cm4gcHVsbFJlcXVlc3RzO1xufVxuXG5mdW5jdGlvbiBnZXRMaW5rZWRJc3N1ZXMoX3B1bGxSZXF1ZXN0czogR2l0aHViUHVsbFJlcXVlc3RbXSk6IGFueVtdIHsgLy8gVE9ETzogdHlwZSBwcm9wZXJseVxuICByZXR1cm4gW107XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHJ1bigpOiBQcm9taXNlPHZvaWQ+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBvcHRpb25zID0gZ2V0T3B0aW9ucygpO1xuICAgIGNvbnN0IHsgb3duZXIsIHJlcG8gfSA9IGdldENvbnRleHQoKTtcblxuICAgIGlmIChvcHRpb25zLm1vZGUgIT09IEFjdGlvbk1vZGUuTEFURVNUKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgXCJsYXRlc3RcIiBtb2RlIGlzIGN1cnJlbnRseSBzdXBwb3J0ZWQuJyk7XG4gICAgfVxuXG4gICAgY29uc3QgdG9rZW4gPSBjb3JlLmdldElucHV0KCd0b2tlbicsIHsgcmVxdWlyZWQ6IHRydWUgfSk7XG5cbiAgICBpZiAodG9rZW4gPT09ICdERUJVR19UT0tFTicpIHtcbiAgICAgIGNvcmUuaW5mbygnREVCVUdfVE9LRU4gaGFzIGJlZW4gcHJvdmlkZWQsIGV4aXRpbmcgZWFybHkuJyk7XG4gICAgICBjb3JlLnNldE91dHB1dCgndG90YWwtY29tbWVudHMnLCAwKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBvY3Rva2l0ID0gZ2l0aHViLmdldE9jdG9raXQodG9rZW4pO1xuICAgIGNvbnN0IGdpdGh1YkNsaWVudCA9IG5ldyBHaXRodWJDbGllbnQob2N0b2tpdCwgb3duZXIsIHJlcG8pO1xuICAgIGNvbnN0IGdpdENsaWVudCA9IG5ldyBHaXRDbGllbnQoKTtcblxuICAgIGNvbnN0IHsgZGF0YTogbGF0ZXN0UmVsZWFzZSB9ID0gYXdhaXQgZ2l0aHViQ2xpZW50LmdldExhdGVzdFJlbGVhc2UoKTtcbiAgICBjb3JlLmRlYnVnKGBsYXRlc3QgcmVsZWFzZTogJHtKU09OLnN0cmluZ2lmeShsYXRlc3RSZWxlYXNlKX1gKTtcbiAgICBjb25zdCBwdWxsUmVxdWVzdHMgPSBhd2FpdCBnZXRQdWxsUmVxdWVzdHMoZ2l0Q2xpZW50LCBnaXRodWJDbGllbnQsIGxhdGVzdFJlbGVhc2UpO1xuICAgIGNvcmUuZGVidWcoJ3B1bGwgcmVxdWVzdHM6JyArIHB1bGxSZXF1ZXN0cy5tYXAoKHByKSA9PiBwci50aXRsZSkuam9pbignXFxuJykpO1xuXG4gICAgZ2V0TGlua2VkSXNzdWVzKHB1bGxSZXF1ZXN0cyk7IC8vIFRPRE9cblxuICAgIC8vIGNvbnN0IHRvdGFsQ29tbWVudHMgPSBhd2FpdCBjb21tZW50T24ocHVsbFJlcXVlc3RzLCBpc3N1ZXMsIHJlbGVhc2UpO1xuXG4gICAgY29yZS5pbmZvKCdTdWNjZXNzIScpO1xuICAgIGNvcmUuc2V0T3V0cHV0KCd0b3RhbC1jb21tZW50cycsIDApOyAvLyBUT0RPXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29yZS5zZXRGYWlsZWQoZXJyb3IubWVzc2FnZSk7XG4gIH1cbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1mbG9hdGluZy1wcm9taXNlc1xucnVuKCk7Il19